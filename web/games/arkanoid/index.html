<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arkanoid</title>
    <link rel="stylesheet" href="/shared/styles.css" />
    <style>
      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: #030712;
        padding-right: var(--debug-width);
      }

      .layout {
        display: grid;
        place-items: center;
        padding: 16px;
      }

      canvas {
        display: block;
        background: #000;
        border: 1px solid #666;
      }

      #lockHint {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        font-family: Consolas, "Courier New", monospace;
        font-size: 14px;
        text-align: center;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "preact": "../../vendor/preact.module.js"
        }
      }
    </script>
  </head>

  <body>
    <div id="lockHint">Click canvas to lock mouse</div>
    <div class="layout">
      <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>
    <div id="tuningRoot"></div>

    <script type="module">
      import { html, render } from "preact";
      import init, {
        engine_init,
        engine_step,
        game_state_len,
        game_state_ptr,
      } from "../../dist/gamedev_wasm_hello.js";
      import { createInputHandler } from "/shared/input.js";
      import App from "./app.js";

      const SNAP = Object.freeze({
        PADDLE_X: 0,
        PADDLE_Y: 1,
        PADDLE_WIDTH: 2,
        PADDLE_HEIGHT: 3,
        BALL_X: 4,
        BALL_Y: 5,
        BALL_SIZE: 6,
      });

      const BOUNCE_ZONE_COLORS = Object.freeze(
        Array.from({ length: 8 }, (_, i) => {
          const t = Math.abs(i - 3.5) / 3.5;
          const r = Math.round(255 * t);
          const g = 0;
          const b = Math.round(255 * (1 - t));
          return `rgb(${r}, ${g}, ${b})`;
        }),
      );

      let lastTime = 0;
      let mouseDeltaX = 0;

      const keys = createInputHandler({
        left: ["ArrowLeft", "a", "A"],
        right: ["ArrowRight", "d", "D"],
      });

      async function run() {
        const wasmModule = await init();
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const lockHint = document.getElementById("lockHint");

        canvas.addEventListener("click", async () => {
          if (!document.pointerLockElement) {
            await canvas.requestPointerLock();
          }
        });

        document.addEventListener("mousemove", (e) => {
          if (document.pointerLockElement === canvas) {
            mouseDeltaX += e.movementX;
          }
        });

        document.addEventListener("pointerlockchange", () => {
          if (document.pointerLockElement === canvas) {
            canvas.style.cursor = "none";
            lockHint.style.display = "none";
          } else {
            canvas.style.cursor = "default";
            lockHint.style.display = "block";
            mouseDeltaX = 0;
          }
        });

        engine_init("Arkanoid", 800, 600);
        render(html`<${App} />`, document.getElementById("tuningRoot"));

        function gameLoop(currentTimeMs) {
          const currentTimeSec = currentTimeMs / 1000.0;
          const deltaTime = lastTime === 0 ? 0 : currentTimeSec - lastTime;
          lastTime = currentTimeSec;

          if (deltaTime > 0.0) {
            const clampedDelta = Math.max(
              -256,
              Math.min(256, Math.round(mouseDeltaX)),
            );
            const deltaEncoded = (clampedDelta & 0xffff) << 16;

            const input_bits =
              (keys.left ? 0b0100 : 0) |
              (keys.right ? 0b1000 : 0) |
              deltaEncoded;

            engine_step(deltaTime, input_bits);
            mouseDeltaX = 0;
          }

          const statePtr = game_state_ptr();
          const stateLen = game_state_len();
          if (statePtr !== 0 && stateLen >= SNAP.BALL_SIZE + 1) {
            const snapshot = new Float32Array(
              wasmModule.memory.buffer,
              statePtr,
              stateLen,
            );
            const paddleX = snapshot[SNAP.PADDLE_X];
            const paddleY = snapshot[SNAP.PADDLE_Y];
            const paddleWidth = snapshot[SNAP.PADDLE_WIDTH];
            const paddleHeight = snapshot[SNAP.PADDLE_HEIGHT];
            const ballX = snapshot[SNAP.BALL_X];
            const ballY = snapshot[SNAP.BALL_Y];
            const ballSize = snapshot[SNAP.BALL_SIZE];

            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const paddleLeft = paddleX - paddleWidth / 2;
            const paddleTop = paddleY - paddleHeight / 2;
            const zoneWidth = paddleWidth / 8;
            for (let zoneIndex = 0; zoneIndex < 8; zoneIndex += 1) {
              const zoneLeft = paddleLeft + zoneIndex * zoneWidth;
              ctx.fillStyle = BOUNCE_ZONE_COLORS[zoneIndex];
              ctx.fillRect(zoneLeft, paddleTop, zoneWidth, paddleHeight);
            }

            ctx.strokeStyle = "#0b111f";
            ctx.lineWidth = 1;
            for (let divider = 1; divider < 8; divider += 1) {
              const x = paddleLeft + divider * zoneWidth;
              ctx.beginPath();
              ctx.moveTo(x, paddleTop);
              ctx.lineTo(x, paddleTop + paddleHeight);
              ctx.stroke();
            }

            ctx.fillStyle = "#ffff00";
            ctx.fillRect(
              ballX - ballSize / 2,
              ballY - ballSize / 2,
              ballSize,
              ballSize,
            );
          }

          requestAnimationFrame(gameLoop);
        }

        requestAnimationFrame(gameLoop);
      }

      run();
    </script>
  </body>
</html>
